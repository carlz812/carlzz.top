---
title: http长连接
categories:
  - 前端
  - http
date: 2017-09-21 10:35:46
tags: http 
---

### 什么是长连接

在http/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次http操作，就建立一次连接，但任务结束就中断连接。
比如在请求页面时，除了html文件外的资源，比如css,js,图片等，每遇到一个文件，都要建立起一个HTTP会话。

从http/1.1开始，默认使用长连接。在使用长连接的情况下，当一个网页打开之后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件商设定这个时间，实现长连接要客户端和服务端都支持长连接。

使用长连接的http协议，会在相应头中加入这行代码：

{% codeblock %}
Connection:keep-alive
{% endcodeblock %}

### HTTP协议与TCP/IP协议的关系

TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。
在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。
在传输层中有TCP协议与UDP协议。
在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。

{% asset_img tcpip.jpeg tcpip %}

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。

### TCP短连接

我们模拟一下TCP短连接的情况，client 向server发起连接请求，server接到请求，然后双方建立连接。client 向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作。

为什么呢？一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作

短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。

短连接的操作步骤是：
建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接

### TCP长连接

长连接的情况：client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

首先说一下TCP 的keep-alive 功能，keep-alive主要为服务器应用提供，服务器应用希望知道客户是否还在请求资源，如果客户端已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将永远处于等待客户端数据的状态，keep-alive就是试图检测到这种半开放状态的连接。

如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：

* 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
* 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
* 客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
* 客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。
从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。

在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。